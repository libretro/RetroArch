## Skeleton config file for RetroArch

# Save all save files (*.srm) to this directory. This includes related files like .bsv, .rtc, .psrm, etc ...
# This will be overridden by explicit command line options.
# savefile_directory =

# Save all save states (*.state) to this directory.
# This will be overridden by explicit command line options.
# savestate_directory =

# Automatically saves a savestate at the end of RetroArch's lifetime.
# The path is $SRAM_PATH.auto.
# RetroArch will automatically load any savestate with this path on startup if savestate_auto_load is set.
# savestate_auto_save = false
# savestate_auto_load = true

# Load libretro from a dynamic location for dynamically built RetroArch.
# This option is mandatory.

# If a directory, RetroArch will look through the directory until it finds an implementation
# that appears to support the extension of the ROM loaded.
# This could fail if ROM extensions overlap.
# libretro_path = "/path/to/libretro.so"

# Environment variables internally in RetroArch.
# Implementations can tap into this user-specificed information to enable functionality
# that is deemed too obscure to expose directly.
# Some variables might be "standardized" at a later time if needed.
# The string is formatted as key value pairs delimited by a semicolon ';'.
# Any white space between the delimiter ';' and the '=' is significant.
# I.e.: "key1=value1;key2=value2;..."
# environment_variables =

# Sets the "system" directory.
# Implementations can query for this directory to load BIOSes, system-specific configs, etc.
# system_directory =

#### Video

# Video driver to use. "gl", "xvideo", "sdl"
# video_driver = "gl"

# Which OpenGL context implementation to use.
# Possible ones for desktop are: glx, x-egl, kms-egl, sdl-gl, wgl.
# By default, tries to use first suitable driver.
# video_gl_context =

# Windowed xscale and yscale
# (Real x res: base_size * xscale * aspect_ratio, real y res: base_size * yscale)
# video_xscale = 3.0
# video_yscale = 3.0

# Fullscreen resolution. Resolution of 0 uses the resolution of the desktop.
# video_fullscreen_x = 0
# video_fullscreen_y = 0

# Start in fullscreen. Can be changed at runtime.
# video_fullscreen = false

# If fullscreen, prefer using a windowed fullscreen mode.
# video_windowed_fullscreen = true

# Which monitor to prefer. 0 (default) means no particular monitor is preferred, 1 and up (1 being first monitor),
# suggests RetroArch to use that particular monitor.
# video_monitor_index = 0

# Forcibly disable composition. Only works in Windows Vista/7 for now.
# video_disable_composition = false

# Video vsync.
# video_vsync = true

# Use threaded video driver. Using this might improve performance at possible cost of latency and more video stuttering.
# video_threaded = false

# Smoothens picture with bilinear filtering. Should be disabled if using pixel shaders.
# video_smooth = true

# Forces rendering area to stay equal to game aspect ratio or as defined in video_aspect_ratio.
# video_force_aspect = true

# Only scales video in integer steps.
# The base size depends on system-reported geometry and aspect ratio.
# If video_force_aspect is not set, X/Y will be integer scaled independently.
# video_scale_integer = false

# A floating point value for video aspect ratio (width / height).
# If this is not set, aspect ratio is assumed to be automatic.
# Behavior then is defined by video_aspect_ratio_auto.
# video_aspect_ratio =

# If this is true and video_aspect_ratio is not set,
# aspect ratio is decided by libretro implementation.
# If this is false, 1:1 PAR will always be assumed if video_aspect_ratio is not set.
# video_aspect_ratio_auto = false

# Forces cropping of overscanned frames.
# Exact behavior of this option is implementation specific.
# video_crop_overscan = false

# Path to Cg shader.
# video_cg_shader = "/path/to/cg/shader.cg"

# Path to GLSL XML shader. If both Cg shader path and XML shader path are defined, 
# Cg shader will take priority unless overridden in video_shader_type.
# video_bsnes_shader = "/path/to/bsnes/xml/shader.shader"

# Which shader type to use. Valid values are "cg", "bsnes", "none" and "auto"
# video_shader_type = auto

# Defines a directory where XML shaders are kept.
# video_shader_dir =

# Render to texture first. Useful when doing multi-pass shaders or control the output of shaders better.
# video_render_to_texture = false

# Defines the video scale of render-to-texture. 
# The output FBO size is scaled by these amounts against the input size (typically 256 * 224 for SNES).
# video_fbo_scale_x = 2.0
# video_fbo_scale_y = 2.0

# Define shader to use for second pass (needs render-to-texture).
# video_second_pass_shader = "/path/to/second/shader.{cg,shader}"

# Defines if bilinear filtering is used during second pass (needs render-to-texture).
# video_second_pass_smooth = true

# CPU-based filter. Path to a bSNES CPU filter (*.filter)
# video_filter =

# Path to a TTF font used for rendering messages. This path must be defined to enable fonts.
# Do note that the _full_ path of the font is necessary!
# video_font_path = 

# Size of the TTF font rendered.
# video_font_size = 48

# Attempt to scale the font to fit better for multiple window sizes.
# video_font_scale = true

# Enable usage of OSD messages.
# video_font_enable = true

# Offset for where messages will be placed on screen. Values are in range 0.0 to 1.0 for both x and y values. 
# [0.0, 0.0] maps to the lower left corner of the screen.
# video_message_pos_x = 0.05
# video_message_pos_y = 0.05

# Color for message. The value is treated as a hexadecimal value.
# It is a regular RGB hex number, i.e. red is "ff0000".
# video_message_color = ffffff

# Video refresh rate of your monitor.
# Used to calculate a suitable audio input rate.
# video_refresh_rate = 59.95

# Allows libretro cores to set rotation modes.
# Setting this to false will honor, but ignore this request.
# This is useful for vertically oriented games where one manually rotates the monitor.
# video_allow_rotate = true

#### Audio

# Enable audio.
# audio_enable = true

# Audio output samplerate.
# audio_out_rate = 48000

# Which resampler to use. "sinc" and "hermite" are currently implemented.
# Default will use "sinc" if compiled in.
# audio_resampler =

# When altering audio_in_rate on-the-fly, define by how much each time.
# audio_rate_step = 0.25

# Audio driver backend. Depending on configuration possible candidates are: alsa, pulse, oss, jack, rsound, roar, openal, sdl, xaudio.
# audio_driver =

# Override the default audio device the audio_driver uses. This is driver dependant. E.g. ALSA wants a PCM device, OSS wants a path (e.g. /dev/dsp), Jack wants portnames (e.g. system:playback1,system:playback_2), and so on ...
# audio_device =

# External DSP plugin that processes audio before it's sent to the driver.
# audio_dsp_plugin =

# Will sync (block) on audio. Recommended.
# audio_sync = true

# Desired audio latency in milliseconds. Might not be honored if driver can't provide given latency.
# audio_latency = 64

# Enable experimental audio rate control.
# audio_rate_control = true

# Controls audio rate control delta. Defines how much input rate can be adjusted dynamically.
# Input rate = in_rate * (1.0 +/- audio_rate_control_delta)
# audio_rate_control_delta = 0.005

# Audio volume. Volume is expressed in dB.
# 0 dB is normal volume. No gain will be applied.
# Gain can be controlled in runtime with input_volume_up/input_volume_down.
# audio_volume = 0.0

#### Input

# Input driver. Depending on video driver, it might force a different input driver.
# input_driver = sdl

# Defines axis threshold. Possible values are [0.0, 1.0]
# input_axis_threshold = 0.5

# Path to input overlay
# input_overlay =

# Enable input auto-detection (used on Android). Will attempt to autoconfigure
# gamepads, Plug-and-Play style.
# input_autodetect_enable = true

# Enable debug input key reporting on-screen.
# input_debug_enable = false

# Keyboard input. Will recognize normal keypresses and special keys like "left", "right", and so on.
# Keyboard input, Joypad and Joyaxis will all obey the "nul" bind, which disables the bind completely, 
# rather than relying on a default.
# input_player1_a = x
# input_player1_b = z
# input_player1_y = a
# input_player1_x = s
# input_player1_start = enter
# input_player1_select = rshift
# input_player1_l = q
# input_player1_r = w
# input_player1_left = left
# input_player1_right = right
# input_player1_up = up
# input_player1_down = down
# input_player1_l2 =
# input_player1_r2 =
# input_player1_l3 =
# input_player1_r3 =

# Two analog sticks (DualShock-esque).
# Bound as usual, however, if a real analog axis is bound,
# it can be read as a true analog.
# Positive X axis is right, Positive Y axis is down.
# input_player1_l_x_plus =
# input_player1_l_x_minus =
# input_player1_l_y_plus =
# input_player1_l_y_minus =
# input_player1_r_x_plus =
# input_player1_r_x_minus =
# input_player1_r_y_plus =
# input_player1_r_y_minus =

# If desired, it is possible to override which joypads are being used for player 1 through 5. First joypad available is 0.
# input_player1_joypad_index = 0
# input_player2_joypad_index = 1
# input_player3_joypad_index = 2
# input_player4_joypad_index = 3
# input_player5_joypad_index = 4
# Player 6-8 is not directly expected by libretro API, but we'll futureproof it.
# input_player6_joypad_index = 5
# input_player7_joypad_index = 6
# input_player8_joypad_index = 7

# Joypad buttons.
# Figure these out by using RetroArch-Phoenix or retroarch-joyconfig.
# You can use joypad hats with hnxx, where n is the hat, and xx is a string representing direction. 
# E.g. "h0up"
# input_player1_a_btn =
# input_player1_b_btn =
# input_player1_y_btn =
# input_player1_x_btn =
# input_player1_start_btn =
# input_player1_select_btn =
# input_player1_l_btn =
# input_player1_r_btn =
# input_player1_left_btn =
# input_player1_right_btn =
# input_player1_up_btn =
# input_player1_down_btn =
# input_player1_l2_btn =
# input_player1_r2_btn =
# input_player1_l3_btn =
# input_player1_r3_btn =

# Axis for RetroArch D-Pad. 
# Needs to be either '+' or '-' in the first character signaling either positive or negative direction of the axis, then the axis number. 
# Do note that every other input option has the corresponding _btn and _axis binds as well; they are omitted here for clarity.
# input_player1_left_axis =
# input_player1_right_axis =
# input_player1_up_axis =
# input_player1_down_axis =

# Holding the turbo while pressing another button will let the button enter a turbo mode
# where the button state is modulated with a periodic signal.
# The modulation stops when the button itself (not turbo button) is released.
# input_player1_turbo =

# Describes the period and how long of that period a turbo-enabled button should behave.
# Numbers are described in frames.
# input_turbo_period = 6
# input_turbo_duty_cycle = 3

# This goes all the way to player 8 (*_player2_*, *_player3_*, etc), but omitted for clarity.
# All input binds have corresponding binds for keyboard (none), joykeys (_btn) and joyaxes (_axis) as well.

# Toggles fullscreen.
# input_toggle_fullscreen = f

# Saves state.
# input_save_state = f2
# Loads state.
# input_load_state = f4

# State slots. With slot set to 0, save state name is *.state (or whatever defined on commandline).
# When slot is != 0, path will be $path%d, where %d is slot number.
# input_state_slot_increase = f7
# input_state_slot_decrease = f6

# Toggles between fast-forwarding and normal speed.
# input_toggle_fast_forward = space

# Hold for fast-forward. Releasing button disables fast-forward.
# input_hold_fast_forward = l

# Key to exit emulator cleanly. 
# Killing it in any hard way (SIGTERM, SIGKILL, etc, will terminate emulator without saving RAM, etc.)
# input_exit_emulator = escape

# Applies next and previous XML/Cg shader in directory.
# input_shader_next = m
# input_shader_prev = n

# Hold button down to rewind. Rewinding must be enabled.
# input_rewind = r

# Toggle between recording and not.
# input_movie_record_toggle = o

# Toggle between paused and non-paused state
# input_pause_toggle = p

# Frame advance when game is paused
# input_frame_advance = k

# Reset the emulated SNES.
# input_reset = h

# Configures DSP plugin
# input_dsp_config = c

# Cheats.
# input_cheat_index_plus = y
# input_cheat_index_minus = t
# input_cheat_toggle = u

# Mute/unmute audio
# input_audio_mute = f9

# Take screenshot
# input_screenshot = f8

# Netplay flip players.
# input_netplay_flip_players = i

# Hold for slowmotion.
# input_slowmotion = e

# Enable other hotkeys.
# If this hotkey is bound to either keyboard, joybutton or joyaxis,
# all other hotkeys will be disabled unless this hotkey is also held at the same time.
# This is useful for RETRO_KEYBOARD centric implementations
# which query a large area of the keyboard, where it is not desirable
# that hotkeys get in the way.

# Alternatively, all hotkeys for keyboard could be disabled by the user.
# input_enable_hotkey =

# Increases audio volume.
# input_volume_up = kp_plus
# Decreases audio volume.
# input_volume_down = kp_minus

# Toggles to next overlay. Wraps around.
# input_overlay_next =

# Toggles eject for disks. Used for multiple-disk games.
# input_disk_eject_toggle =

# Cycles through disk images. Use after ejecting.
# Complete by toggling eject again.
# input_disk_next =

# Toggles RGUI menu.
# input_menu_toggle = f1

#### Misc

# Enable rewinding. This will take a performance hit when playing, so it is disabled by default.
# rewind_enable = false

# Rewinding buffer size in megabytes. Bigger rewinding buffer means you can rewind longer.
# The buffer should be approx. 20MB per minute of buffer time.
# rewind_buffer_size = 20

# Rewind granularity. When rewinding defined number of frames, you can rewind several frames at a time, increasing the rewinding speed.
# rewind_granularity = 1

# Pause gameplay when window focus is lost.
# pause_nonactive = true

# Autosaves the non-volatile SRAM at a regular interval. This is disabled by default unless set otherwise.
# The interval is measured in seconds. A value of 0 disables autosave.
# autosave_interval =

# When being client over netplay, use keybinds for player 1.
# netplay_client_swap_input = false

# Path to XML cheat database (as used by bSNES).
# cheat_database_path =

# Path to XML cheat config, a file which keeps track of which
# cheat settings are used for individual games.
# If the file does not exist, it will be created.
# cheat_settings_path =

# Directory to dump screenshots to.
# screenshot_directory =

# Records video after CPU video filter.
# video_post_filter_record = false

# Records output of GPU shaded material if available.
# video_gpu_record = false

# Screenshots output of GPU shaded material if available.
# video_gpu_screenshot = true

# Block SRAM from being overwritten when loading save states.
# Might potentially lead to buggy games.
# block_sram_overwrite = false

# When saving a savestate, save state index is automatically increased before
# it is saved.
# Also, when loading a ROM, the index will be set to the highest existing index.
# There is no upper bound on the index.
# savestate_auto_index = false

# Slowmotion ratio. When slowmotion, game will slow down by factor.
# slowmotion_ratio = 3.0

# Enable stdin/network command interface.
# network_cmd_enable = false
# network_cmd_port = 55355
# stdin_cmd_enable = false

